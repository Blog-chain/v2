> string이 문자열의 크기 외에 필요로 하는 메타 정보가 무엇인지, 또 어떤 원리로 조작에 활용되는지 알아보기 위한 귀납적 시도입니다.

### 0. 0개의 인자

`cast calldata "callThis()"`
함수 식별자만 출력합니다. - `0x243da18c`

### 1-1. 1개의 인자, uint256

`cast calldata "callThis(uint256)" 1`
1개의 인자에 대해 32바이트가 추가됩니다.

- `0x860fb2c1`
- `0x0000000000000000000000000000000000000000000000000000000000000001` // uint256: 1

##### ~~이후 zero-padding은 생략합니다.~~

### 1-2. 1개의 인자, string

`cast calldata "callThis(string)" "z"`
동일하게 1개의 인자이지만, 96바이트가 추가됩니다.

- `0x0a976363` // 함수 식별자
- `0x20` // byte offset: 32 > `0x01`
- // string "z" <br>
  `0x01` // 문자열 길이: 1
- `0x7a00000000000000000000000000000000000000000000000000000000000000` // 우측 정렬된 문자열 "z"

```sh
0x0a976363
0x00 0000000000000000000000000000000000000000000000000000000000000020
0x20 0000000000000000000000000000000000000000000000000000000000000001
0x40 7a00000000000000000000000000000000000000000000000000000000000000
```

### 2. 2개의 인자, string, string

`cast calldata "callThis(string, string)" "z" "a"`

- `0x515e7093`
- `0x40` // byte offset: 32 \* 2 > `0x01`("z")
- `0x80` // byte offset: 32 \* 4 > `0x01`("a")
- // string "z" <br>
  `0x01` // 문자열 길이: 1
- `0x7a00000000000000000000000000000000000000000000000000000000000000` // 우측 정렬된 문자열 "z"
- // string "a" <br>
  `0x01`// 문자열 길이: 1
- `0x6100000000000000000000000000000000000000000000000000000000000000` // 우측 정렬된 문자열 "a"

```sh
0x515e7093
0x00 0000000000000000000000000000000000000000000000000000000000000040
0x20 0000000000000000000000000000000000000000000000000000000000000080
0x40 0000000000000000000000000000000000000000000000000000000000000001
0x60 7a00000000000000000000000000000000000000000000000000000000000000
0x80 0000000000000000000000000000000000000000000000000000000000000001
0xa0 6100000000000000000000000000000000000000000000000000000000000000
```

### 3. 3개의 인자, string, uint256, string

`cast calldata "callThis(string, uint256, string)" "zzz" 2 "123456781234567812345678123456780"`

- `0x2ec90e97`
- `0x60` // byte offset: 32 \* 3 > `0x03`("zzz")
- `0x02` // uint256: 2
- `0xa0` // byte offset: 32 \* 5 > `0x21`("12..80")
- // string "zzz" <br>
- `0x03` // 문자열 길이: 3
- `0x7a7a7a0000000000000000000000000000000000000000000000000000000000` // string "zzz"
- // string "12..80" <br>
  `0x21` // 문자열 길이: 33
- `0x3132333435363738313233343536373831323334353637383132333435363738` // string "12345678" \* 4
- `0x3000000000000000000000000000000000000000000000000000000000000000` // string "0"

<br>

```sh
0x00 0000000000000000000000000000000000000000000000000000000000000060 offset zzz
0x20 0000000000000000000000000000000000000000000000000000000000000002 uint
0x40 00000000000000000000000000000000000000000000000000000000000000a0 offset 123..
0x60 0000000000000000000000000000000000000000000000000000000000000003 size zzz
0x80 7a7a7a0000000000000000000000000000000000000000000000000000000000 string zzz
0xa0 0000000000000000000000000000000000000000000000000000000000000021 size 123..
0xc0 3132333435363738313233343536373831323334353637383132333435363738 string 123(1) 
0xe0 3000000000000000000000000000000000000000000000000000000000000000 string 123(2)
```


---

<br>

- 전달된 인자의 순서는 고정이다.

- `bytes`, `string`, 정적/가변 배열 `<T>[]`은 모두 가변 인자이다. 이들은 실제 데이터는 먼 곳에 저장해두고, offset을 제공하여 참조 순서를 보장한다.

- 동일한 배열이더라도 정적 배열은 offset 대신 바로 size(length)를 전달하고, 뒤로 인자들을 나열한다.


<br>

---

<br>

### Reference

- https://degatchi.com/articles/reading-raw-evm-calldata/
- https://www.rareskills.io/post/abi-encoding
